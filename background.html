<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@4.0.0/dist/simplex-noise.min.js"></script>
    <style>
        body {
            background: #000;
            overflow: hidden;
            margin: 0;
        }
    </style>
</head>

<body>
    <script>
        let palette = [
            new THREE.Color("#808080"),
            new THREE.Color("#808080"),
            new THREE.Color("#808080"),
            new THREE.Color("#808080")
        ];

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        const renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (window.devicePixelRatio > 1.5) {
            renderer.setPixelRatio(2);
        }
        document.body.appendChild(renderer.domElement);

        camera.position.x = 4;
        camera.position.y = 0;
        camera.position.z = 12;

        const linesMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2,
            blending: THREE.AdditiveBlending,
            vertexColors: true
        });

        const group = new THREE.Group();
        scene.add(group);

        let points = [];
        const linesGeometry = new THREE.BufferGeometry();
        const line = new THREE.LineSegments(linesGeometry, linesMaterial);
        group.add(line);

        const garden = [];
        class Grass {
            constructor() {
                this.theta = Math.random() * Math.PI;
                this.phi = Math.random() * Math.PI * 2;
                let u = Math.cos(this.theta);
                let x = 5.5 * Math.sqrt(1 - u * u) * Math.cos(this.phi);
                let y = 5.5 * Math.sqrt(1 - u * u) * Math.sin(this.phi);
                let z = 5.5 * u;
                this.pos = new THREE.Vector3(x, y, z);
                this.pos2 = new THREE.Vector3();
                this.scale = 5.1 + Math.random() * 0.8;
                this.colorIndex = Math.floor(Math.abs(1));
                colors.push(
                    palette[this.colorIndex].r,
                    palette[this.colorIndex].g,
                    palette[this.colorIndex].b
                );
                this.colorIndex += 1;
                colors.push(
                    palette[this.colorIndex % 4].r,
                    palette[this.colorIndex % 4].g,
                    palette[this.colorIndex % 4].b
                );
            }

            update(a) {
                const angle = Math.random() / 20;
                const u = Math.cos(this.theta + (angle + 0.01));
                this.pos2.x =
                    this.scale *
                    Math.sqrt(1 - u * u) *
                    Math.cos(this.phi + Math.sin((angle + 0.01) * Math.PI));
                this.pos2.y =
                    this.scale *
                    Math.sqrt(1 - u * u) *
                    Math.sin(this.phi + Math.sin((angle + 0.01) * Math.PI));
                this.pos2.z = this.scale * u;

                points.push(this.pos.x, this.pos.y, this.pos.z);
                points.push(this.pos2.x, this.pos2.y, this.pos2.z);
            }
        }

        let colors = [];
        for (let i = 0; i < 40000; i++) {
            const g = new Grass();
            garden.push(g);
        }

        linesGeometry.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(colors, 3)
        );

        let isMouseNearGrass = false;

        window.addEventListener("mousemove", onMouseMove, false);

        function onMouseMove(event) {
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            isMouseNearGrass = false;

            garden.forEach((grass) => {
                const grassScreenPos = grass.pos.clone().project(camera);
                const distX = Math.abs(grassScreenPos.x - mouseX);
                const distY = Math.abs(grassScreenPos.y - mouseY);

                if (distX < 0.1 && distY < 0.1) {
                    isMouseNearGrass = true;
                    grass.update();
                }
            });
        }

        function render(a) {
            requestAnimationFrame(render);

            points = [];
            if (isMouseNearGrass) {
                garden.forEach((grass) => {
                    grass.update(a * 0.0003);
                });
                linesGeometry.setAttribute(
                    "position",
                    new THREE.Float32BufferAttribute(points, 3)
                );
            }

            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }

        requestAnimationFrame(render);

        window.addEventListener("resize", onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
