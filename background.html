<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@4.0.0/dist/simplex-noise.min.js"></script>
    <style>
        body {
            background: #000;
            overflow: hidden;
            margin: 0;
        }
    </style>
</head>

<body>
    <script>
        //alert(screen.width*screen.height)
        let palette = [
            new THREE.Color("#000000"),
            new THREE.Color("#262626"),
            new THREE.Color("#595959"),
            new THREE.Color("#808080")
        ];

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        const renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (window.devicePixelRatio > 1.5) {
            renderer.setPixelRatio(2);
        }
        document.body.appendChild(renderer.domElement);

        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 120;

        const linesMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2,
            blending: THREE.AdditiveBlending,
            vertexColors: true
        });

        const group = new THREE.Group();
        scene.add(group);

        let points = [];
        const linesGeometry = new THREE.BufferGeometry();
        const line = new THREE.LineSegments(linesGeometry, linesMaterial);
        group.add(line);

        const scale = 0.15;

        const degrees = 20;
        const radians = (degrees * Math.PI) / 180;

        const wOrig = 48;
        const hOrig = 64;
        const w = Math.abs(wOrig * Math.cos(radians)) + Math.abs(hOrig * Math.sin(radians))
        const h = Math.abs(wOrig * Math.sin(radians)) + Math.abs(hOrig * Math.cos(radians))

        function rotateCoordinates(x, y) {
            var cosTheta = Math.cos(radians);
            var sinTheta = Math.sin(radians);

            var newX = x * cosTheta - y * sinTheta;
            var newY = x * sinTheta + y * cosTheta;

            return { x: newX, y: newY };
        }

        function isInsideP(xOrig, yOrig) {
            const rotatedCoordinates = rotateCoordinates(xOrig, yOrig);
            let x = rotatedCoordinates.x;
            let y = rotatedCoordinates.y

            if (x < (wOrig / 6) * scale && x > -(wOrig / 6) * scale && y < hOrig * scale && y > -hOrig * scale) {
                return true;
            }

            const hemispheres = [1, -1];
            for (var i = 0; i < hemispheres.length; i++) {
                xHem = x * hemispheres[i];
                yHem = y * hemispheres[i];
                if (xHem > (wOrig / 6) * scale && yHem > 0 * scale && xHem < wOrig * scale && yHem < hOrig * scale) {
                    if (xHem < (wOrig * 2 / 3) * scale && (yHem > (hOrig * 3 / 4) * scale || yHem < (hOrig / 4) * scale)) {
                        return true;
                    }

                    if (xHem > (wOrig * 2 / 3) * scale && (yHem > (hOrig / 4) * scale && yHem < (hOrig * 3 / 4) * scale)) {
                        return true;
                    }

                    if (xHem > (wOrig * 2 / 3) * scale && yHem > (hOrig * 3 / 4) * scale) {
                        if (Math.pow(xHem - (wOrig * 2 / 3) * scale, 2) + Math.pow(yHem - (hOrig * 3 / 4) * scale, 2) < Math.pow((wOrig / 3) * scale, 2)) {
                            return true;
                        }
                    }

                    if (xHem > 32 * scale && yHem < 16 * scale) {
                        if (Math.pow(xHem - (wOrig * 2 / 3) * scale, 2) + Math.pow(yHem - (hOrig / 4) * scale, 2) < Math.pow((wOrig / 3) * scale, 2)) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        function generateRandomP() {
            let x, y;
            do {
                x = (-w + Math.random() * w * 2) * scale / Math.cos(radians);
                y = (-h + Math.random() * h * 2) * scale;
            } while (!isInsideP(x, y));
            
            return { x, y };
        }

        const garden = [];
        class Grass {
            constructor() {
                //let x = 35.5 * (2 * Math.random() - 1)
                //let y = 35.5 * (2 * Math.random() - 1)
                const randomCoords = generateRandomP();
                let x = randomCoords.x;
                let y = randomCoords.y;

                let xOffset = (Math.floor(Math.random() * 20) - 10) * w * scale * 2;
                let yOffset = (Math.floor(Math.random() * 10) - 5) * h * scale * 2;

                x += xOffset;
                y += yOffset;

                let z = 1
                this.pos = new THREE.Vector3(x, y, z);
                this.pos2 = new THREE.Vector3();
                this.scale = 5.1 + Math.random() * 0.8;
                this.colorIndex = Math.floor(Math.random() * 4);
                colors.push(
                    palette[this.colorIndex].r,
                    palette[this.colorIndex].g,
                    palette[this.colorIndex].b
                );
                this.colorIndex += 1;
                colors.push(
                    palette[this.colorIndex % 4].r,
                    palette[this.colorIndex % 4].g,
                    palette[this.colorIndex % 4].b
                );
				
				this.pos2.x = this.pos.x + Math.random()
                this.pos2.y = this.pos.y + Math.random()
                this.pos2.z = 0

                this.nearby = false
            }

            update() {
				if (this.nearby) {
					this.pos2.x = this.pos.x + Math.random()
					this.pos2.y = this.pos.y + Math.random()
					this.pos2.z = 0
				}

                points.push(this.pos.x, this.pos.y, this.pos.z);
                points.push(this.pos2.x, this.pos2.y, this.pos2.z);

                this.nearby = false
            }
        }

        let colors = [];
        for (let i = 0; i < ((screen.width*screen.height) * scale); i++) {
            const g = new Grass();
            garden.push(g);
        }

        linesGeometry.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(colors, 3)
        );

        window.addEventListener("mousemove", onMouseMove, false);

        function onMouseMove(event) {
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            garden.forEach((grass) => {
                const grassScreenPos = grass.pos.clone().project(camera);
                const distX = Math.abs(grassScreenPos.x - mouseX);
                const distY = Math.abs(grassScreenPos.y - mouseY) / (screen.width / screen.height);
                const distance = Math.sqrt(distX * distX + distY * distY);

                if (distance < 0.02) {
                    grass.nearby = true;
                }
				else {
					grass.nearby = false;
				}
            });
        }

        function render(a) {
            requestAnimationFrame(render);

            points = [];
            
            garden.forEach((grass) => {
                grass.update();
            });

            linesGeometry.setAttribute(
                "position",
                new THREE.Float32BufferAttribute(points, 3)
            );

            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }

        requestAnimationFrame(render);

        window.addEventListener("resize", onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
