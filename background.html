<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@4.0.0/dist/simplex-noise.min.js"></script>
    <style>
        body {
            background: #000;
            overflow: hidden;
            margin: 0;
        }
    </style>
</head>

<body>
    <script>
        //alert(screen.width*screen.height)
        let palette = [
            new THREE.Color("#808080"),
            new THREE.Color("#808080"),
            new THREE.Color("#808080"),
            new THREE.Color("#808080")
        ];

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        const renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (window.devicePixelRatio > 1.5) {
            renderer.setPixelRatio(2);
        }
        document.body.appendChild(renderer.domElement);

        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 12;

        const linesMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2,
            blending: THREE.AdditiveBlending,
            vertexColors: true
        });

        const group = new THREE.Group();
        scene.add(group);

        let points = [];
        const linesGeometry = new THREE.BufferGeometry();
        const line = new THREE.LineSegments(linesGeometry, linesMaterial);
        group.add(line);

        const garden = [];
        class Grass {
            constructor() {
                let x = 5.5 * (2 * Math.random() - 1)
                let y = 5.5 * (2 * Math.random() - 1)
                let z = 0
                this.pos = new THREE.Vector3(x, y, z);
                this.pos2 = new THREE.Vector3();
                this.scale = 5.1 + Math.random() * 0.8;
                this.colorIndex = Math.floor(Math.abs(1));
                colors.push(
                    palette[this.colorIndex].r,
                    palette[this.colorIndex].g,
                    palette[this.colorIndex].b
                );
                this.colorIndex += 1;
                colors.push(
                    palette[this.colorIndex % 4].r,
                    palette[this.colorIndex % 4].g,
                    palette[this.colorIndex % 4].b
                );
				
				this.pos2.x = this.pos.x + Math.random()
                this.pos2.y = this.pos.y + Math.random()
                this.pos2.z = 0
            }

            update(a) {
				if (a) {
					this.pos2.x = this.pos.x + Math.random()
					this.pos2.y = this.pos.y + Math.random()
					this.pos2.z = 0
				}

                points.push(this.pos.x, this.pos.y, this.pos.z);
                points.push(this.pos2.x, this.pos2.y, this.pos2.z);
            }
        }

        let colors = [];
        for (let i = 0; i < ((screen.width*screen.height)/90); i++) {
            const g = new Grass();
            garden.push(g);
        }

        linesGeometry.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(colors, 3)
        );

        let nearbyGrass = [];

        window.addEventListener("mousemove", onMouseMove, false);

        function onMouseMove(event) {
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            nearbyGrass = [];
			farGrass = [];

            garden.forEach((grass) => {
                const grassScreenPos = grass.pos.clone().project(camera);
                const distX = Math.abs(grassScreenPos.x - mouseX);
                const distY = Math.abs(grassScreenPos.y - mouseY) / (screen.width / screen.height);
                const distance = Math.sqrt(distX * distX + distY * distY);

                if (distance < 0.05) {
                    nearbyGrass.push(grass);
                }
				else {
					farGrass.push(grass);
				}
            });
        }

        function render(a) {
            requestAnimationFrame(render);

            points = [];
            
            nearbyGrass.forEach((grass) => {
                grass.update(true);
            });
			
			farGrass.forEach((grass) => {
                grass.update(false);
            });

            linesGeometry.setAttribute(
                "position",
                new THREE.Float32BufferAttribute(points, 3)
            );

            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }

        requestAnimationFrame(render);

        window.addEventListener("resize", onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
